[
 "import numpy as np\ndot_prod = np.dot(arr1, arr2)",
 "dot_prod = sum(arr1 * arr2)",
 "dot_prod = (arr1 @ arr2).item()",
 "import functools\ndot_prod = functools.reduce(lambda a, b: a + b, [arr1[i] * arr2[i] for i in range(len(arr1))])",
 "import itertools\ndot_prod = sum((a * b for (a, b) in itertools.zip(arr1, arr2)))",
 "import numpy as np\ndot_prod = np.sum(np.multiply(arr1, arr2))",
 "import numpy as np\ndot_prod = np.dot(arr1.T, arr2)",
 "import numpy as np\ndot_prod = np.dot(arr1, arr2.T)",
 "import numpy as np\ndot_prod = np.matmul(arr1, arr2)",
 "import numpy as np\ndot_prod = np.einsum('ij,ij->i', arr1, arr2)",
 "import numpy as np\ndot_prod = np.tensordot(arr1, arr2, axes=1)",
 "import numpy as np\ndot_prod = np.vdot(arr1, arr2)",
 "import numpy as np\ndot_prod = np.inner(arr1, arr2)",
 "import numpy as np\ndot_prod = np.matmul(arr1, arr2, out=arr3)",
 "import numpy as np\ndot_prod = np.dot(arr1, arr2, out=arr3)",
 "import numpy as np\ndot_prod = np.einsum('ij,ij->i', arr1, arr2, out=arr3)",
 "import numpy as np\ndot_prod = np.tensordot(arr1, arr2, axes=1, out=arr3)",
 "import numpy as np\ndot_prod = np.vdot(arr1, arr2, out=arr3)",
 "import numpy as np\ndot_prod = np.inner(arr1, arr2, out=arr3)",
 "import numpy as np\ndot_prod = np.cross(arr1, arr2, out=arr3)",
 "dot_prod = arr1 @ arr2",
 "dot_prod = arr1.dot(arr2)",
 "dot_prod = sum((a * b for (a, b) in enumerate(arr1, arr2)))",
 "import numpy as np\ndot_prod = np.dot(arr1.conj(), arr2)",
 "import numpy as np\ndot_prod = np.dot(arr1.T.conj(), arr2.conj())",
 "import numpy as np\ndot_prod = np.dot(arr1.T, arr2.T.conj())",
 "import numpy as np\ndot_prod = np.sum(arr1 * arr2.T)",
 "import numpy as np\ndot_prod = np.sum(arr1 * arr2.conj())",
 "import numpy as np\ndot_prod = np.sum(arr1.T * arr2)",
 "import numpy as np\ndot_prod = np.sum(arr1.T * arr2.conj())",
 "import numpy as np\ndot_prod = arr1 * arr2.T",
 "import numpy as np\ndot_prod = arr1 * arr2.conj()",
 "import numpy as np\ndot_prod = arr1.T * arr2",
 "import numpy as np\ndot_prod = arr1.T * arr2.conj()",
 "import numpy as np\ndot_prod = arr1 @ arr2.T",
 "import numpy as np\ndot_prod = arr1.T @ arr2",
 "import numpy as np\ndot_prod = np.sum(arr1.conj() * arr2)",
 "import numpy as np\ndot_prod = np.sum(arr1.conj() * arr2.conj())",
 "import numpy as np\ndot_prod = arr1 * arr2",
 "import numpy as np\ndot_prod = arr1.conj() * arr2",
 "import numpy as np\ndot_prod = arr1.conj() * arr2.conj()",
 "import numpy as np\ndot_prod = arr1.T.dot(arr2)",
 "import numpy as np\ndot_prod = arr1.dot(arr2.T)",
 "import numpy as np\ndot_prod = arr1.T.dot(arr2.T)",
 "import numpy as np\ndot_prod = np.sum(arr1 * arr2, axis=1)",
 "import numpy as np\ndot_prod = np.sum(arr1 * arr2, axis=0)",
 "import numpy as np\ndot_prod = np.einsum('ij,jk->ik', arr1, arr2)",
 "import numpy as np\ndot_prod = arr1.dot(arr2.T).sum()",
 "dot_prod = sum(arr1 * arr2.T)",
 "dot_prod = sum((a * b for (a, b) in zip(arr1, arr2.T)))",
 "import numpy as np\ndot_prod = np.dot(arr1, arr2.conj().T)",
 "import numpy as np\ndot_prod = np.einsum('ij,ji->i', arr1, arr2)",
 "import numpy as np\ndot_prod = np.dot(arr1, arr2.conj())",
 "dot_prod = 0\nfor i in range(len(arr1)):\n    for j in range(len(arr2[0])):\n        dot_prod += arr1[i][j] * arr2[j][i]",
 "dot_prod = sum([sum([arr1[i][j] * arr2[i][j] for j in range(len(arr1[0]))]) for i in range(len(arr1))])",
 "dot_prod = arr1[0] * arr2[0] + arr1[1] * arr2[1] + arr1[2] * arr2[2]",
 "import numpy as np\ndot_prod = np.dot(arr1, arr2).sum(axis=-1)",
 "import numpy as np\ndot_prod = np.sum(arr1 * arr2, axis=-1)",
 "import numpy as np\ndot_prod = np.matmul(arr1, arr2.T, out=arr3)",
 "import numpy as np\ndot_prod = np.matmul(arr1.T, arr2, out=arr3)",
 "import numpy as np\ndot_prod = np.dot(arr1.conj(), arr2.conj().T, out=arr3)",
 "import numpy as np\ndot_prod = np.matmul(arr1.conj(), arr2.conj().T, out=arr3)",
 "dot_prod = sum((arr1[i] * arr2[i] for i in range(arr1.shape[0])))",
 "dot_prod = np.dot(arr1, arr2, out=arr3) if arr3 is not None else np.dot(arr1, arr2)",
 "dot_prod = sum((a * b for a in arr1 for b in arr2.T))",
 "dot_prod = (arr1 * arr2).sum()",
 "import numpy as np\ndot_prod = np.sum(arr1[:, np.newaxis] * arr2[np.newaxis, :])",
 "dot_prod = sum((a * b for (a, b) in zip(arr1.flatten(), arr2.flatten())))",
 "import numpy as np\ndot_prod = np.sum(arr1[:, None] * arr2[None, :])",
 "import numpy as np\ndot_prod = np.sum(arr1 * arr2, axis=(1, 0))",
 "import numpy as np\ndot_prod = np.tensordot(arr1, arr2, axes=(1, 0))",
 "import numpy as np\ndot_prod = np.tensordot(arr1, arr2, axes=())",
 "import numpy as np\ndot_prod = np.tensordot(arr1, arr2, axes=(-1, -1))",
 "import numpy as np\ndot_prod = np.einsum('ij,ij->', arr1, arr2, dtype=np.float64, optimize=True, casting='unsafe')",
 "dot_prod = sum((a * b for (a, b) in zip(arr1.reshape(-1), arr2.reshape(-1))))",
 "dot_prod = sum((a * b for (a, b) in zip(arr1.reshape(-1, 1), arr2.reshape(1, -1))))",
 "dot_prod = sum((arr1[i] * arr2[i] for i in range(arr1.shape[1])))",
 "import numpy as np\ndot_prod = np.dot(arr1, arr2)[0, 0]",
 "dot_prod = sum(sum((row * col for (row, col) in zip(arr1, arr2))))",
 "import functools\ndef inner_func(arr1, arr2):\n    return functools.reduce(lambda x, y: x + y, [arr1[i] * arr2[i] for i in range(len(arr1))])\ndot_prod = inner_func(arr1, arr2)",
 "for i in range(len(arr1)):\n    dot_prod += arr1[i] * arr2[i]",
 "import numpy as np\nresult = np.inner(arr1, arr2)\ndot_prod = result[0, 0]",
 "import numpy as np\nresult = arr1.dot(arr2)\ndot_prod = result",
 "from functools import reduce\ndot_prod = reduce(lambda x, y: x + y, [arr1[i] * arr2[i] for i in range(len(arr1))])",
 "dot_prod = 0\nfor a in arr:\n    dot_prod += a",
 "import numpy as np\nprod = np.inner(arr1, arr2)\ndot_prod = prod",
 "import numpy as np\ndt = np.dot(arr1, arr2)\ndot_prod = dt[0, 0]",
 "import numpy as np\nprod = np.sum(np.multiply(arr1, arr2))\ndot_prod = prod",
 "import numpy as np\ndt = np.matmul(arr1, arr2.T)\ndot_prod = dt[0, 0]",
 "import numpy as np\ndot_prod = np.inner(arr1.T, arr2)",
 "import numpy as np\ndot_prod = np.matmul(arr1.T, arr2.T)",
 "import numpy as np\ndot_prod = np.linalg.multi_dot([arr1.T, arr2.T, arr2])",
 "import numpy as np\nresult = np.sum(arr1 * arr2)\ndot_prod = result",
 "dot_prod = sum(arr1 @ arr2)",
 "dot_prod = arr[0] + arr[1] + arr[2]",
 "sum(arr[0], arr[1], arr[2], arr[3])",
 "arr[0] + arr[1] + arr[2] + arr[3]",
 "arr[0] * arr[1] + arr[1] * arr[2] + arr[2] * arr[3] + arr[3] * arr[0]",
 "(arr * arr).sum()",
 "def dot_prod(arr1, arr2):\n    return sum(arr1 * arr2)\ndot_prod(arr1, arr2)",
 "from numpy import dot\ndot_prod = dot(arr1, arr2)",
 "from functools import reduce\ndot_prod = reduce(lambda a, b: a + b, arr1 * arr2)",
 "dot_prod = sum(list(zip(arr1, arr2))[0] * list(zip(arr1, arr2))[1])",
 "arr1_transpose = arr1.T\ndot_prod = np.dot(arr1_transpose, arr2)",
 "from functools import reduce\ndot_prod = reduce(lambda a, b: a + b, list(map(lambda i: arr1[i] * arr2[i], range(len(arr1)))))",
 "def dot(a, b):\n    if len(a) != len(b):\n        raise ValueError('Vectors must have equal length')\n    result = 0\n    for i in range(len(a)):\n        result += a[i] * b[i]\n    return result\ndot_prod = dot(arr1, arr2)",
 "import numpy as np\nreturn np.dot(arr1, arr2)",
 "return sum(arr1 * arr2)",
 "from itertools import product\nimport numpy as np\ndot_prod = sum(sum((x * y for (x, y) in product(arr1, arr2))))",
 "import itertools\nfor (i, x1, x2) in itertools.zip_longest(range(len(arr1)), arr1, arr2):\n    if x1 is not None and x2 is not None:\n        dot_prod += x1 * x2\nfor (i, x1) in enumerate(arr1):\n    if x1 is not None:\n        dot_prod += x1 * arr2[i]\ndot_prod = np.dot(arr1, arr2)",
 "import numpy as np\ndef dot_product(arr1, arr2):\n    return np.sum(arr1 * arr2)\ndot_prod = dot_product(arr1, arr2)",
 "import numpy as np\ndef dot_product(a, b):\n    return sum(a * b)\ndot_prod = dot_product(arr1, arr2)",
 "import numpy as np\ndef dot_product(a, b):\n    result = 0.0\n    for i in range(a.shape[0]):\n        result += a[i] * b[i]\n    return result\ndot_prod = dot_product(arr1, arr2)",
 "import numpy as np\ndef dot_product(arr1, arr2):\n    return np.matmul(arr1, arr2)\ndot_prod = dot_product(arr1, arr2)",
 "import numpy as np\nd = arr1.dot(arr2)\nd = d.item()\ndot_prod = d",
 "import numpy as np\narr1 = np.array(arr1)\narr2 = np.array(arr2)\nd = arr1.dot(arr2)\nd = d.item()\ndot_prod = d",
 "from operator import mul\nfrom functools import reduce\ndot_prod = reduce(mul, arr1, initial=1)\nfor value in arr2:\n    dot_prod *= value",
 "from itertools import combinations\ndot_prod = sum([arr1[i] * arr2[j] for (i, j) in combinations(range(len(arr1)), 2)])",
 "for (i, x1) in enumerate(arr1):\n    dot_prod += x1 * arr2[i]",
 "import numpy as np\nnp.sum(arr1 * arr2)",
 "import numpy as np\ndef dot_product(a, b):\n    return np.sum(a * b)\ndot_prod = dot_product(arr1, arr2)",
 "import numpy as np\ndot_prod = np.dot(arr1.reshape(-1), arr2.reshape(-1))",
 "import numpy as np\narr1 = np.array(arr1)\narr2 = np.array(arr2)\ndot_prod = np.dot(arr1, arr2)",
 "import numpy as np\narr1 = np.array(arr1)\narr2 = np.array(arr2)\ndot_prod = sum(arr1 * arr2)",
 "dot_prod = sum((list(zip(*arr1))[i] * list(zip(*arr2))[i] for i in range(len(arr1[0]))))",
 "{'dot_prod': 0}\nfor i in range(len(arr1)):\n    {'dot_prod': dot_prod + arr1[i] * arr2[i]}",
 "import functools\ndot_prod = functools.reduce(lambda x, y: x + y[0] * y[1], list(zip(arr1, arr2)))",
 "import collections\ndot_prod = collections.Counter(zip(arr1, arr2)).values().sum()"
]