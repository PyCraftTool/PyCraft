[
 "dot_prod = sum((i * j for (i, j) in zip(arr1, arr2)))",
 "dot_prod = 0\nfor (i, j) in zip(arr1, arr2):\n    dot_prod += i * j",
 "from functools import reduce\nfrom operator import add\ndot_prod = reduce(add, (i * j for (i, j) in zip(arr1, arr2)))",
 "from operator import mul\nfrom itertools import starmap\ndot_prod = sum(starmap(mul, zip(arr1, arr2)))",
 "import functools\nimport operator\ndot_prod = functools.reduce(operator.add, map(operator.mul, arr1, arr2))",
 "dot_prod = sum(map(lambda x, y: x * y, arr1, arr2))",
 "import numpy as np\ndot_prod = np.tensordot(arr1, arr2, axes=0)",
 "from functools import reduce\nimport operator\ndot_prod = reduce(operator.add, map(operator.mul, arr1, arr2))",
 "import itertools\ndot_prod = sum((a * b for (a, b) in itertools.zip_longest(arr1, arr2, fillvalue=0)))",
 "import itertools\nimport operator\ndot_prod = sum(itertools.starmap(operator.mul, zip(arr1, arr2)))",
 "dot_prod = 0\ni = 0\nj = 0\nwhile i < len(arr1) and j < len(arr2):\n    dot_prod += arr1[i] * arr2[j]\n    i += 1\n    j += 1",
 "from functools import reduce\nfrom operator import mul\ndot_prod = reduce(mul, [i * j for (i, j) in zip(arr1, arr2)])",
 "dot_prod = sum(map(lambda a, b: a * b, arr1, arr2))",
 "from itertools import accumulate\nfrom operator import mul\ndot_prod = list(accumulate(map(mul, arr1, arr2)))[-1]",
 "import numpy as np\ndot_prod = np.multiply.outer(arr1, arr2)",
 "dot_prod = sum([i * j for (i, j) in zip(arr1, arr2)])",
 "from operator import mul\nfrom functools import reduce\ndot_prod = reduce(lambda a, b: a + b, map(mul, arr1, arr2))",
 "import functools\nimport operator\ndot_prod = sum((functools.reduce(operator.mul, data) for data in zip(arr1, arr2)))",
 "import itertools\nimport operator\ndot_prod = sum(map(operator.mul, arr1, arr2))",
 "from functools import reduce\nimport operator\ndot_prod = reduce(operator.add, (a * b for (a, b) in zip(arr1, arr2)))",
 "dot_prod = 0\nfor i in range(min(len(arr1), len(arr2))):\n    dot_prod += arr1[i] * arr2[i]",
 "dot_prod = sum([arr1[i] * arr2[i] for i in range(min(len(arr1), len(arr2)))])",
 "from functools import reduce\nimport operator\ndot_prod = reduce(operator.add, [arr1[i] * arr2[i] for i in range(min(len(arr1), len(arr2)))])",
 "from operator import mul\nfrom functools import reduce\ndot_prod = reduce(lambda x, y: x + y, map(mul, arr1, arr2))",
 "dot_prod = 0\nfor (a, b) in zip(arr1, arr2):\n    temp = a * b\n    dot_prod += temp",
 "from functools import reduce\nfrom operator import mul\ndot_prod = reduce(mul, [temp for temp in [i * j for (i, j) in zip(arr1, arr2)]])",
 "import functools\ndot_prod = functools.reduce(lambda a, b: a + b, [a * b for (a, b) in zip(arr1, arr2)])",
 "import numpy as np\narr1_expanded = np.expand_dims(np.expand_dims(arr1, -1), -1)\narr2_expanded = np.expand_dims(np.expand_dims(arr2, 0), 0)\ndot_prod = arr1_expanded * arr2_expanded",
 "import numpy as np\ndot_prod = np.einsum('i,j->ij', arr1, arr2)",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        dot_prod[i][j] = arr1[i] * arr2[j]",
 "import numpy as np\ndot_prod = np.array([[i * j for j in arr2] for i in arr1])",
 "import numpy as np\ndot_prod = np.outer(arr1, arr2)",
 "dot_prod = [[i * j for j in arr2] for i in arr1]",
 "import itertools\nimport numpy as np\ndot_prod = np.array([i * j for (i, j) in itertools.product(arr1, arr2)]).reshape(len(arr1), len(arr2))",
 "import functools\ndot_prod = functools.reduce(lambda x, y: x + y, [i * j for (i, j) in zip(arr1, arr2)])",
 "dot_prod = 0\nfor pair in zip(arr1, arr2):\n    dot_prod += pair[0] * pair[1]",
 "import math\ndot_prod = sum((math.prod(pair) for pair in zip(arr1, arr2)))",
 "dot_prod = 0\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        if i == j:\n            dot_prod += arr1[i] * arr2[j]",
 "from itertools import starmap\nimport operator\ndot_prod = sum(starmap(operator.mul, zip(arr1, arr2)))",
 "import math\ndot_prod = math.fsum((i * j for (i, j) in zip(arr1, arr2)))",
 "dot_prod = 0\ni = 0\nwhile i < min(len(arr1), len(arr2)):\n    dot_prod += arr1[i] * arr2[i]\n    i += 1",
 "dot_prod = 0\nfor (i, (a, b)) in enumerate(zip(arr1, arr2)):\n    dot_prod += a * b",
 "dot_prod = 0\ni = 0\ntry:\n    while True:\n        dot_prod += arr1[i] * arr2[i]\n        i += 1\nexcept IndexError:\n    pass",
 "from functools import reduce\nimport operator\ndot_prod = reduce(operator.add, map(operator.mul, arr1, arr2), 0)",
 "dot_prod = 0\ni = 0\nwhile i < len(arr1) and i < len(arr2):\n    dot_prod += arr1[i] * arr2[i]\n    i += 1",
 "dot_prod = 0\nfor (i, _) in enumerate(arr1):\n    if i < len(arr2):\n        dot_prod += arr1[i] * arr2[i]",
 "dot_prod = 0\narr2 = arr2 + [0] * (len(arr1) - len(arr2))\nfor i in range(len(arr1)):\n    dot_prod += arr1[i] * arr2[i]",
 "dot_prod = 0\nfor i in range(len(arr1)):\n    if i < len(arr2):\n        dot_prod += arr1[i] * arr2[i]",
 "import math\nimport functools\ndot_prod = functools.reduce(lambda a, b: a + b, [math.prod(pair) for pair in zip(arr1, arr2)])",
 "dot_prod = 0\nfor i in range(len(arr1)):\n    try:\n        dot_prod += arr1[i] * arr2[i]\n    except IndexError:\n        break",
 "from functools import reduce\nfrom operator import add\ndot_prod = reduce(add, (arr1[i] * arr2[i] for i in range(min(len(arr1), len(arr2)))))",
 "dot_prod = 0\ni = 0\nwhile i < len(arr1):\n    try:\n        dot_prod += arr1[i] * arr2[i]\n        i += 1\n    except IndexError:\n        break",
 "from functools import reduce\nfrom operator import add, mul\ndot_prod = reduce(add, map(mul, arr1, arr2), 0)",
 "dot_prod = 0\nfor (i, val) in enumerate(arr1):\n    if i < len(arr2):\n        dot_prod += val * arr2[i]",
 "from operator import mul\nfrom itertools import starmap\nfrom functools import reduce\ndot_prod = reduce(lambda a, b: a + b, starmap(mul, zip(arr1, arr2)))",
 "import functools\nimport operator\ndot_prod = functools.reduce(operator.add, map(operator.mul, arr1, arr2), 0)",
 "dot_prod = 0\ni = 0\nwhile True:\n    try:\n        dot_prod += arr1[i] * arr2[i]\n        i += 1\n    except IndexError:\n        break",
 "import itertools\ndot_prod = sum((a * b for (a, b) in itertools.zip_longest(arr1, arr2, fillvalue=1)))",
 "import itertools\ndot_prod = sum(itertools.starmap(lambda x, y: x * y, zip(arr1, arr2)))",
 "import numpy as np\ndot_prod = np.dot(arr1[:len(arr2)], arr2)",
 "dot_prod = sum((val * arr2[i] for (i, val) in enumerate(arr1) if i < len(arr2)))",
 "from functools import reduce\nfrom operator import add\ndot_prod = reduce(add, (val * arr2[i] for (i, val) in enumerate(arr1) if i < len(arr2)), 0)",
 "dot_prod = 0\nfor val in arr1:\n    if arr1.index(val) < len(arr2):\n        dot_prod += val * arr2[arr1.index(val)]",
 "from itertools import starmap, zip_longest\ndot_prod = sum(starmap(lambda x, y: x * y, zip_longest(arr1, arr2, fillvalue=0)))",
 "dot_prod = 0\nfor a in arr1:\n    for b in arr2:\n        dot_prod += a * b\n        break",
 "from operator import mul\nimport functools\ndot_prod = functools.reduce(lambda a, b: a + b, map(mul, arr1, arr2))",
 "from operator import mul\nimport functools\ndot_prod = sum(map(mul, arr1, arr2))",
 "import numpy as np\ndot_prod = np.inner(arr1[:len(arr2)], arr2)",
 "import numpy as np\ndot_prod = np.matmul(arr1[:len(arr2)], arr2)",
 "import numpy as np\ndot_prod = np.tensordot(arr1[:len(arr2)], arr2, axes=0)",
 "import numpy as np\nfrom functools import reduce\ndot_prod = reduce(lambda x, y: x + y, [arr1[i] * arr2[i] for i in range(len(arr2))])",
 "import numpy as np\nfrom operator import mul\ndot_prod = sum(map(mul, arr1[:len(arr2)], arr2))",
 "import numpy as np\nfrom itertools import starmap\ndot_prod = sum(starmap(lambda x, y: x * y, zip(arr1[:len(arr2)], arr2)))",
 "import numpy as np\ndot_prod = np.dot(arr1[:len(arr2)], arr2[:len(arr2)])",
 "dot_prod = sum(map(lambda x, y: x * y, arr1[:len(arr2)], arr2[:len(arr2)]))",
 "import functools\nimport operator\ndot_prod = functools.reduce(operator.add, (val * arr2[i] for (i, val) in enumerate(arr1) if i < len(arr2)))",
 "dot_prod = sum(map(lambda x, y: x * y, arr1[:len(arr2)], arr2))",
 "from functools import reduce\nfrom operator import add, mul\ndot_prod = reduce(add, map(mul, arr1[:len(arr2)], arr2), 0)",
 "from functools import reduce\nfrom operator import mul\ndot_prod = reduce(lambda x, y: x + y, map(mul, arr1[:len(arr2)], arr2))",
 "import numpy as np\ndot_prod = np.dot(arr1, arr2[0])",
 "dot_prod = sum((a * arr2[0] for a in arr1))",
 "dot_prod = 0\nfor i in range(len(arr1)):\n    dot_prod += arr1[i] * arr2[0]",
 "dot_prod = 0\ni = 0\nwhile i < len(arr1):\n    dot_prod += arr1[i] * arr2[0]\n    i += 1",
 "from functools import reduce\ndot_prod = reduce(lambda x, y: x + y * arr2[0], arr1, 0)",
 "dot_prod = 0\nfor (index, a) in enumerate(arr1):\n    dot_prod += a * arr2[0]\n    if index == len(arr1) - 1:\n        break",
 "from functools import reduce\nimport operator\ndot_prod = reduce(operator.add, (a * arr2[0] for a in arr1), 0)",
 "from functools import reduce\nimport operator\ndot_prod = reduce(operator.add, [arr1[i] * arr2[i] for i in range(len(arr2))])",
 "import numpy as np\ndot_prod = np.sum(np.multiply(arr1[:len(arr2)], arr2))",
 "from functools import reduce\nimport operator\ndot_prod = reduce(operator.add, (arr1[i] * arr2[i] for i in range(len(arr2))))",
 "import functools\nimport operator\ndot_prod = functools.reduce(operator.add, map(operator.mul, arr1[:len(arr2)], arr2))",
 "dot_prod = sum((arr1[i] * arr2[i] for i in range(min(len(arr1), len(arr2)))))",
 "import functools\nimport operator\ndot_prod = functools.reduce(operator.add, (arr1[i] * arr2[i] for i in range(len(arr2))))",
 "import numpy as np\narr1_sliced = arr1[:len(arr2)]\ndot_prod = np.dot(arr1_sliced, arr2)",
 "dot_prod = sum((i * j for (i, j) in zip(arr1[:len(arr2)], arr2)))",
 "import numpy as np\ndot_prod = np.matmul(np.array(arr1[:len(arr2)]).reshape(1, -1), np.array(arr2).reshape(-1, 1))",
 "import numpy as np\ndot_prod = np.matmul(arr1[:len(arr2)], arr2[:len(arr2)])",
 "import numpy as np\nfrom itertools import starmap\ndot_prod = sum(starmap(lambda a, b: a * b, zip(arr1, arr2)))",
 "from math import fsum\ndot_prod = fsum((a * b for (a, b) in zip(arr1, arr2)))",
 "from operator import mul\nfrom functools import reduce\ndot_prod = reduce(lambda x, y: x + y, [mul(a, b) for (a, b) in zip(arr1, arr2)])",
 "from operator import mul\nfrom functools import reduce\ndot_prod = reduce(mul, [arr1[i] * arr2[i] for i in range(len(arr1))])",
 "import math\ndot_prod = 0\nfor (a, b) in zip(arr1, arr2):\n    dot_prod += math.prod([a, b])",
 "import functools\ndot_prod = functools.reduce(lambda a, b: a + b[0] * b[1], zip(arr1, arr2), 0)",
 "import itertools\nfuncs = [lambda x, y: x * y for _ in range(len(arr1))]\ndot_prod = sum(map(lambda f, x, y: f(x, y), itertools.cycle(funcs), arr1, arr2))",
 "import itertools\ndot_prod = 0\nfor (x, y) in itertools.zip_longest(arr1, arr2, fillvalue=1):\n    dot_prod += x * y",
 "import functools\nimport operator\ndot_prod = functools.reduce(operator.add, (a * b for (a, b) in zip(arr1, arr2)))",
 "from functools import reduce\nimport operator\ndot_prod = reduce(lambda x, y: x + y, map(operator.mul, arr1, arr2))",
 "from operator import mul\nfrom functools import reduce\nmul_arr = map(mul, arr1, arr2)\ndot_prod = reduce(lambda a, b: a + b, mul_arr)",
 "import itertools\ndot_prod = sum(itertools.starmap(lambda a, b: a * b, zip(arr1, arr2)))",
 "import functools\ndot_prod = functools.reduce(lambda sum, pair: sum + pair[0] * pair[1], zip(arr1, arr2), 0)",
 "import numpy as np\ndot_prod = sum((i[0] * i[1] for i in zip(arr1, arr2)))",
 "from functools import reduce\nimport operator\narr1_np = arr1\narr2_np = arr2\ndot_prod = reduce(operator.add, map(operator.mul, arr1, arr2))",
 "import itertools\nimport operator\ndot_prod = 0\nfor (i, j) in itertools.product(arr1, arr2):\n    dot_prod += operator.mul(i, j)",
 "from itertools import starmap, zip_longest\ndot_prod = sum(starmap(lambda x, y: x * y, zip_longest(arr1, arr2, fillvalue=1)))",
 "from itertools import starmap, zip_longest\nfrom operator import mul\ndot_prod = sum(starmap(mul, zip_longest(arr1, arr2, fillvalue=1)))",
 "import itertools\nimport operator\ndot_prod = sum(map(operator.mul, itertools.islice(arr1, len(arr2)), arr2))",
 "import functools\nimport operator\nimport itertools\ndot_prod = functools.reduce(operator.mul, itertools.starmap(operator.mul, zip(arr1, arr2)))",
 "import functools\nimport operator\ndot_prod = functools.reduce(operator.add, [a * b for (a, b) in zip(arr1, arr2)])",
 "import functools\ndot_prod = functools.reduce(lambda total, values: total + values[0] * values[1], zip(arr1, arr2), 0)",
 "dot_prod = sum(map(lambda a, b: a * b, zip(arr1, arr2)))",
 "import numpy as np\n(arr1, arr2) = map(np.array, (arr1, arr2))\nif arr1.shape != arr2.shape:\n    size = min(arr1.size, arr2.size)\n    (arr1, arr2) = (x[:size] for x in (arr1, arr2))\ndot_prod = arr1.dot(arr2)",
 "from operator import mul\nfrom itertools import starmap\nfrom functools import reduce\nproduct = list(starmap(mul, zip(arr1, arr2)))\ndot_prod = reduce(lambda a, b: a + b, product)",
 "from functools import reduce\ndot_prod = reduce(lambda a, b: a + b, [a * b for (a, b) in zip(arr1, arr2)])",
 "from operator import mul\nimport itertools\nit = itertools.starmap(mul, zip(arr1, arr2))\ndot_prod = sum(it)",
 "from operator import mul\nfrom itertools import starmap\nfrom functools import reduce\ndot_prod = reduce(lambda x, y: x + y, starmap(mul, zip(arr1, arr2)))",
 "import numpy as np\nfrom operator import mul\nfrom math import fsum\ndot_prod = fsum(map(mul, arr1, arr2))",
 "from math import fsum\nfrom operator import mul\ndot_prod = fsum((mul(a, b) for (a, b) in zip(arr1, arr2)))",
 "import numpy as np\nfrom math import fsum\ndot_prod = fsum([i * j for (i, j) in zip(arr1, arr2)])",
 "from math import fsum\nimport itertools as it\ndot_prod = fsum((x * y for (x, y) in it.zip_longest(arr1, arr2, fillvalue=0)))",
 "dot_prod = []\nfor i in arr1:\n    row = []\n    for j in arr2:\n        row.append(i * j)\n    dot_prod.append(row)",
 "from functools import reduce\ndot_prod = [[reduce(lambda x, y: x * y, [i, j]) for j in arr2] for i in arr1]",
 "import operator\ndot_prod = [[operator.mul(i, j) for j in arr2] for i in arr1]",
 "dot_prod = list(map(lambda i: list(map(lambda j: i * j, arr2)), arr1))",
 "import numpy as np\ndot_prod = np.outer(arr1, arr2).tolist()",
 "from itertools import product\ndot_prod = [a * b for (a, b) in product(arr1, arr2)]",
 "dot_prod = []\nfor i in arr1:\n    dot_prod.append([i * j for j in arr2])",
 "dot_prod = sum(map(lambda pair: pair[0] * pair[1], zip(arr1, arr2)))",
 "dot_prod = 0\ni = 0\nwhile i < len(arr1) and i < len(arr2):\n    dot_prod += arr1[i] * arr2[i]\n    i += 1\nelse:\n    pass",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        dot_prod[i, j] = arr1[i] * arr2[j]",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor (i, val1) in enumerate(arr1):\n    for (j, val2) in enumerate(arr2):\n        dot_prod[i][j] = val1 * val2",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = arr1[i] * arr2",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        dot_prod[i][j] = np.dot(arr1[i], arr2[j])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = np.multiply(arr1[i], arr2)",
 "import numpy as np\ndot_prod = np.dot(np.array(arr1)[:, None], np.array(arr2)[None, :])",
 "import numpy as np\ndot_prod = np.dot(np.array([arr1]).T, np.array([arr2]))",
 "from itertools import product\ndot_prod = [[i * j for (i, j) in product([x], arr2)] for x in arr1]",
 "dot_prod = list(map(lambda x: list(map(lambda y: x * y, arr2)), arr1))",
 "import numpy as np\narr1_expanded = np.expand_dims(arr1, axis=1)\narr2_expanded = np.expand_dims(arr2, axis=0)\ndot_prod = np.dot(arr1_expanded, arr2_expanded)",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor (i, val1) in enumerate(arr1):\n    for (j, val2) in enumerate(arr2):\n        dot_prod[i, j] = val1 * val2",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i, :] = np.multiply(arr1[i], arr2)",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor j in range(len(arr2)):\n    dot_prod[:, j] = np.multiply(arr1, arr2[j])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        dot_prod[i, j] = np.dot(arr1[i], arr2[j])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        dot_prod[i, j] = np.multiply(arr1[i], arr2[j])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = np.array([a * b for (a, b) in zip([arr1[i]] * len(arr2), arr2)])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor j in range(len(arr2)):\n    dot_prod[:, j] = np.array([a * b for (a, b) in zip(arr1, [arr2[j]] * len(arr1))])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor (i, val1) in enumerate(arr1):\n    dot_prod[i] = np.multiply(val1, arr2)",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = [val1 * val2 for val2 in arr2]",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = list(map(lambda x: x * arr1[i], arr2))",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = np.array([val1 * val2 for val2 in arr2])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = np.array(list(map(lambda x: x * arr1[i], arr2)))",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor (i, val) in enumerate(arr1):\n    dot_prod[i] = val * arr2",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = np.dot(arr1[i], arr2)",
 "import numpy as np\ndot_prod = np.array([val1 * arr2 for val1 in arr1])",
 "import numpy as np\ndot_prod = np.array([[np.dot(arr1[i], arr2[j]) for j in range(len(arr2))] for i in range(len(arr1))])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor (i, vec1) in enumerate(arr1):\n    for (j, vec2) in enumerate(arr2):\n        dot_prod[i][j] = np.dot(vec1, vec2)",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    dot_prod[i] = np.dot(arr1[i], np.array(arr2).T)",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        dot_prod[i][j] = sum((a * b for (a, b) in zip(arr1[i], arr2[j])))",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in range(len(arr1)):\n    for j in range(len(arr2)):\n        dot_prod[i][j] = sum(np.multiply(arr1[i], arr2[j]))",
 "import numpy as np\ndot_prod = np.array([np.multiply(val, arr2) for val in arr1])",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in np.arange(len(arr1)):\n    dot_prod[i] = np.multiply(arr1[i], arr2)",
 "import numpy as np\ndot_prod = np.zeros((len(arr1), len(arr2)))\nfor i in np.arange(len(arr1)):\n    for j in np.arange(len(arr2)):\n        dot_prod[i][j] = arr1[i] * arr2[j]",
 "import numpy as np\ndot_prod = np.matmul(np.array(arr1).reshape(-1, 1), np.array(arr2).reshape(1, -1))",
 "import numpy as np\narr1_np = np.array(arr1)\narr2_np = np.array(arr2)\ndot_prod = np.dot(arr1_np.reshape(-1, 1), arr2_np.reshape(1, -1))",
 "import numpy as np\narr1_np = np.array(arr1)\narr2_np = np.array(arr2)\ndot_prod = np.matmul(arr1_np[:, None], arr2_np[None, :])",
 "import numpy as np\narr1_np = np.array(arr1)\narr2_np = np.array(arr2)\ndot_prod = np.outer(arr1_np, arr2_np)",
 "import numpy as np\ndot_prod = np.dot(np.array(arr1).reshape(-1, 1), np.array(arr2).reshape(1, -1))",
 "import numpy as np\narr1_np = np.array(arr1)\narr2_np = np.array(arr2)\ndot_prod = np.dot(arr1_np[:, None], arr2_np[None, :])",
 "import numpy as np\narr1_np = np.array(arr1)\narr2_np = np.array(arr2)\ndot_prod = np.matmul(arr1_np.reshape(-1, 1), arr2_np.reshape(1, -1))",
 "import itertools\nimport operator\ndef dot_product(arr1, arr2):\n    return sum(map(operator.mul, arr1, arr2))\ndot_prod = dot_product(arr1, arr2)",
 "import operator\nfrom functools import reduce\nres = list(map(operator.mul, arr1, arr2))\ndot_prod = reduce(operator.add, res)",
 "single_elements = [a * b for (a, b) in zip(arr1, arr2)]\ndot_prod = sum(single_elements)",
 "import functools as fn\ndot_prod = fn.reduce(lambda x, y: x + y[0] * y[1], zip(arr1, arr2), 0)",
 "def dot_product(arr1, arr2):\n    return sum((i * j for (i, j) in zip(arr1, arr2)))\ndot_prod = dot_product(arr1, arr2)",
 "import operator\ndot_prod = sum(list(map(operator.mul, arr1, arr2)))",
 "dot_prod = sum(list(map(lambda x, y: x * y, arr1, arr2)))",
 "import math\ndot_prod = sum(map(math.prod, zip(arr1, arr2)))",
 "import math\nfrom operator import mul\ndot_prod = math.fsum(map(mul, arr1, arr2))",
 "from functools import reduce\ndot_prod = reduce(lambda x, y: x + y[0] * y[1], zip(arr1, arr2), 0)",
 "dot_prod = 0\nfor (a1, a2) in zip(arr1, arr2):\n    dot_prod = dot_prod + a1 * a2",
 "dot_prod = sum([i[0] * i[1] for i in zip(arr1, arr2)])",
 "dot_prod = sum(tuple((x * y for (x, y) in zip(arr1, arr2))))",
 "from operator import mul\ndot_prod = sum((mul(x, y) for (x, y) in zip(arr1, arr2)))",
 "import functools\nimport operator\nsingle_elements = list(map(operator.mul, arr1, arr2))\ndot_prod = functools.reduce(operator.add, single_elements)",
 "from itertools import starmap, zip_longest\nfrom operator import mul\ndot_prod = sum(starmap(mul, zip_longest(arr1, arr2, fillvalue=0)))",
 "from functools import reduce\ndot_prod = reduce(lambda a, b: a + b[0] * b[1], zip(arr1, arr2), 0)",
 "arr_coupled = list(zip(arr1, arr2))\ndot_prod = sum([val1 * val2 for (val1, val2) in arr_coupled])",
 "import functools\nchunks = [(i, i + 1) for i in range(0, len(arr1), 1)]\npartial_sums = [functools.reduce(lambda x, y: x * y, arr1[start:end] + arr2[start:end]) for (start, end) in chunks]\ndot_prod = sum(partial_sums)",
 "import math\ndot_prod = sum([math.prod(i) for i in zip(arr1, arr2)])",
 "single_elements = list(map(lambda x, y: x * y, arr1, arr2))\ndot_prod = sum(single_elements)",
 "src1 = 0\nfor (a, b) in zip(arr1, arr2):\n    src1 += a * b\ndot_prod = src1",
 "import itertools\nimport operator\ninters_prod = map(operator.mul, arr1, arr2)\ndot_prod = sum(inters_prod)",
 "import operator\ndot_prod = 0\nfor pair in map(operator.mul, arr1, arr2):\n    dot_prod += pair",
 "import itertools\ndot_prod = 0\nfor pair in itertools.zip_longest(arr1, arr2, fillvalue=0):\n    dot_prod += pair[0] * pair[1]",
 "from itertools import accumulate\ndot_prod = list(accumulate((x * y for (x, y) in zip(arr1, arr2))))[-1]",
 "import numpy as np\narr1 = np.array(arr1)\narr2 = np.array(arr2)\nif len(arr1) > len(arr2):\n    arr2 = np.pad(arr2, (0, len(arr1) - len(arr2)), 'constant', constant_values=(1, 1))\nif len(arr1) < len(arr2):\n    arr1 = np.pad(arr1, (0, len(arr2) - len(arr1)), 'constant', constant_values=(1, 1))\ndot_prod = np.dot(arr1, arr2)",
 "import numpy as np\narr1 = np.array(arr1)\narr2 = np.array(arr2)\nif len(arr1) < len(arr2):\n    arr1 = np.pad(arr1, (0, len(arr2) - len(arr1)), 'constant', constant_values=(1, 1))\nelse:\n    arr2 = np.pad(arr2, (0, len(arr1) - len(arr2)), 'constant', constant_values=(1, 1))\ndot_prod = np.sum(arr1 * arr2)",
 "import numpy as np\nimport functools\narr1 = np.array(arr1, float)\narr2 = np.array(arr2, float)\narr1.resize(arr2.shape)\narr2.resize(arr1.shape)\nproduct = np.multiply(arr1, arr2)\ndot_prod = functools.reduce(lambda cumulator, element: cumulator + element, product, 0)",
 "dot_prod = sum((a * b for (a, b) in map(lambda cie: cie if len(cie) == 2 else (cie[0], 1), zip(arr1, arr2))))",
 "dot_prod = 0\nfor i in range(max(len(arr1), len(arr2))):\n    val1 = arr1[i] if i < len(arr1) else 1\n    val2 = arr2[i] if i < len(arr2) else 1\n    dot_prod += val1 * val2",
 "from functools import reduce\ndot_prod = reduce(lambda acc, pair: acc + pair[0] * pair[1], zip(arr1, arr2), 0)",
 "dot_prod = sum((a * b for (a, b) in zip(arr1, arr2))) / (sum((a ** 2 for a in arr1)) * sum((b ** 2 for b in arr2))) ** 0.5"
]