[
 "from functools import reduce\ncounts = reduce(lambda c, i: dict(c, **{i: c.get(i, 0) + 1}), iterable, {})",
 "from itertools import groupby\nfrom operator import itemgetter\ncounts = {key: len(list(group)) for (key, group) in groupby(sorted(iterable))}",
 "from collections import Counter\ncounts = Counter(iterable)\ni = iterable[-1]",
 "i = iterable[-1]\ncounts = {i: iterable.count(i) for i in iterable}",
 "counts = {key: iterable.count(key) for key in iterable}\nfor i in iterable:\n    counts[i] += 1",
 "from collections import defaultdict\nfrom operator import add\ncounts = defaultdict(int)\nfor i in iterable:\n    counts = defaultdict(add, counts)\n    counts[i] += 1",
 "from collections import defaultdict\nimport operator\ncounts = defaultdict(int)\nfor i in iterable:\n    counts[i] += 1\nkey_max = max(counts.items(), key=operator.itemgetter(1))[0]",
 "import numpy as np\ncounts = {i: np.count_nonzero(np.array(iterable) == i) for i in iterable}",
 "import collections\ncounts = collections.Counter(iterable)\ni = iterable[-1]",
 "counts = dict(((i, iterable.count(i)) for i in iterable))\ni = iterable[-1]",
 "counts = {i: iterable.count(i) for i in iterable}\ni = iterable[-1]",
 "import collections\ni = iterable[0]\ncounts = collections.Counter(iterable)",
 "import pandas as pd\ni = iterable[0]\ncounts = pd.Series(iterable).value_counts().to_dict()",
 "import collections\nfrom itertools import chain\ncounts = collections.Counter(chain.from_iterable(iterable))",
 "import numpy as np\ncounts = {i: np.sum(np.array(iterable) == i) for i in iterable}",
 "import numpy as np\ncounts = dict(np.unique(iterable, return_counts=True))",
 "import collections\ncounts = collections.Counter(iterable)\ni = unique[0]",
 "counts = {}\nfor val in iterable:\n    if val in counts:\n        counts[val] += 1\n    else:\n        counts[val] = 1\nunique = list(counts.keys())\ni = unique[0]",
 "import collections\nfrom itertools import cycle\ncounts = collections.Counter(iterable)\ni = next(cycle(iterable))",
 "counts = dict()\nfor item in iterable:\n    if item in counts:\n        counts[item] += 1\n    else:\n        counts[item] = 1\ni = iterable[-1]",
 "counts = dict()\nfor item in iterable:\n    counts[item] = counts.get(item, 0) + 1\ni = iterable[-1]",
 "import functools\nimport operator\ncounts = dict(functools.reduce(operator.add, map(lambda x: {x: 1}, iterable)))\ni = iterable[-1]",
 "import numpy as np\n(np_unique, counts) = np.unique(iterable, return_counts=True)\ncounts = dict(zip(np_unique, counts))\ni = iterable[-1]",
 "counts = {item: iterable.count(item) for item in set(iterable)}\ni = iterable[-1]",
 "import pandas as pd\ndf = pd.DataFrame(iterable, columns=['Item'])\ncounts = df['Item'].value_counts().to_dict()\ni = iterable[-1]",
 "counts = {}\nfor item in iterable:\n    if item not in counts:\n        counts[item] = 1\n    else:\n        counts[item] += 1\ni = iterable[-1]",
 "from functools import reduce\ncounts = reduce(lambda x, y: dict(list(x.items()) + list({y: x.get(y, 0) + 1}.items())), iterable, {})\ni = iterable[-1]",
 "from functools import reduce\ni = None\ncounts = reduce(lambda x, y: dict(((i, x.get(i, 0) + y.get(i, 0)) for i in set(x) | set(y))), map(lambda i: {i: 1}, iterable))",
 "import numpy as np\ncounts = np.bincount(np.array(iterable))",
 "from functools import reduce\ncounts = reduce(lambda x, y: dict(((i, x.get(i, 0) + y.get(i, 0)) for i in set(x) | set(y))), map(lambda x: {x: 1}, iterable))",
 "import pandas as pd\ncounts = pd.Series(iterable).value_counts().to_dict()\nfor i in iterable:\n    pass",
 "import numpy as np\n(unique, counts) = np.unique(iterable, return_counts=True)\ncounts = dict(zip(unique, counts))\ni = iterable[-1] if len(iterable) > 0 else None",
 "from functools import reduce\ncounts = reduce(lambda x, y: dict(((i, x.get(i, 0) + y.get(i, 0)) for i in set(x) | set(y))), (dict({i: 1}) for i in iterable))",
 "from functools import reduce\ncounts = reduce(lambda c, x: c.update({x: c.get(x, 0) + 1}) or c, iterable, {})\ni = iterable[-1]",
 "from functools import reduce\ndef count_fn(counts, i):\n    counts[i] = counts.get(i, 0) + 1\n    return counts\ncounts = reduce(count_fn, iterable, {})\ni = iterable[-1]",
 "import numpy as np\ni = None\ncounts = {key: np.count_nonzero(np.array(iterable) == key) for key in iterable}\nfor i in iterable:\n    pass",
 "from functools import reduce\ni = iterable[-1]\n\ndef count_dict(acc, curr):\n    acc[curr] = acc.get(curr, 0) + 1\n    return acc\ncounts = reduce(count_dict, iterable, {})",
 "from collections import defaultdict\ni = iterable[-1]\ncounts = defaultdict(int)\nfor i in iterable:\n    counts[i] += 1",
 "import numpy as np\n(unique, counts) = np.unique(iterable, return_counts=True)\ncounts = {}\nfor i in range(len(unique)):\n    counts[unique[i]] = counts[i]",
 "import numpy as np\n(unique, counts) = np.unique(iterable, return_counts=True)\ncounts = {}\ni = 0\nwhile i < len(unique):\n    counts[unique[i]] = counts[i]\n    i += 1",
 "import numpy as np\nfrom collections import Counter\ncounts = Counter(np.array(iterable))",
 "import numpy as np\ni = np.array(iterable)\ncounts = {j: list(i).count(j) for j in i}",
 "from functools import reduce\nreduce_func = lambda counts, i: {**counts, i: counts.get(i, 0) + 1}\ncounts = reduce(reduce_func, iterable, {})\ni = iterable[-1]",
 "import numpy as np\niterable_np = np.array(iterable)\n(unique, counts_np) = np.unique(iterable_np, return_counts=True)\ncounts = dict(zip(unique, counts_np))\ni = iterable[-1]",
 "import functools\nimport operator\ncounts = functools.reduce(operator.add, map(lambda x: {x: 1}, iterable))",
 "import numpy as np\nfrom collections import Counter\niterable_np = np.array(iterable)\ncounts = Counter(iterable_np)",
 "import numpy as np\nfrom collections import defaultdict\ncounts = defaultdict(int)\nfor i in np.array(iterable):\n    counts[i] += 1",
 "import numpy as np\niterable_arr = np.array(iterable)\ncounts = np.bincount(iterable_arr)",
 "import numpy as np\niterable_arr = np.array(iterable)\ncounts = np.zeros(iterable_arr.max() + 1)\nfor i in iterable_arr:\n    counts[i] += 1",
 "import numpy as np\niterable_arr = np.array(iterable)\ncounts_dict = {}\nfor i in iterable_arr:\n    if i in counts_dict:\n        counts_dict[i] += 1\n    else:\n        counts_dict[i] = 1\ncounts = np.array([counts_dict.get(i, 0) for i in range(iterable_arr.max() + 1)])",
 "import numpy as np\nfrom collections import Counter\ncounts_dict = Counter(iterable)\niterable_arr = np.array(iterable)\ncounts = np.array([counts_dict.get(i, 0) for i in range(iterable_arr.max() + 1)])",
 "import numpy as np\niterable_arr = np.array(iterable)\ncounts = np.histogram(iterable_arr, bins=np.arange(iterable_arr.max() + 2), density=False)[0]",
 "import numpy as np\nfrom collections import defaultdict\ndict_counts = defaultdict(int)\nfor i in iterable:\n    dict_counts[i] += 1\ncounts = np.array(list(dict_counts.values()))",
 "from functools import reduce\ndef count_elements(acc, i):\n    acc[i] = acc.get(i, 0) + 1\n    return acc\ncounts = reduce(count_elements, iterable, {})\ni = iterable[-1]",
 "from functools import reduce\ncounts = reduce(lambda x, y: {**x, **{y: x.get(y, 0) + 1}}, iterable, {})\ni = iterable[-1]",
 "from functools import reduce\nfrom operator import add\ncounts = reduce(add, map(lambda x: {x: 1}, iterable))",
 "import numpy as np\ni = None\ncounts = {x: list(iterable).count(x) for x in np.unique(iterable)}",
 "counts = {}\nfor item in iterable:\n    if item in counts:\n        counts[item] += 1\n    else:\n        counts[item] = 1\ni = iterable[-1]",
 "from functools import reduce\ndef count_elements(acc, curr):\n    acc[curr] = acc.get(curr, 0) + 1\n    return acc\ncounts = reduce(count_elements, iterable, {})\ni = iterable[-1]",
 "counts = {}\nfor item in iterable:\n    counts[item] = counts.get(item, 0) + 1\ni = iterable[-1]",
 "i = iterable[-1]\ncounts = {}\nfor item in iterable:\n    if item in counts:\n        counts[item] += 1\n    else:\n        counts[item] = 1",
 "import numpy as np\ni = iterable[-1]\ncounts = {item: np.count_nonzero(np.array(iterable) == item) for item in iterable}",
 "i = iterable[-1]\ncounts = {}\nfor item in iterable:\n    counts[item] = counts.get(item, 0) + 1",
 "from functools import reduce\ni = iterable[-1]\ncounts = reduce(lambda x, y: x.update({y: x.get(y, 0) + 1}) or x, iterable, {})",
 "import pandas as pd\ni = iterable[-1]\ncounts = pd.Series(iterable).value_counts().to_dict()",
 "from collections import Counter\ni = iterable[-1]\ncounts = Counter(iterable)",
 "import numpy as np\ni = None\ncounts = {x: np.count_nonzero(np.array(iterable) == x) for x in iterable}",
 "from collections import Counter\n(i, counts) = zip(*Counter(iterable).items())\ncounts = dict(zip(i, counts))",
 "import numpy as np\niterable_np = np.array(iterable)\n(unique, counts_np) = np.unique(iterable_np, return_counts=True)\ncounts = {k: v for (k, v) in zip(unique, counts_np)}\ni = iterable[-1]",
 "import collections\ni = iterable[-1]\ncounts = collections.Counter(iterable)",
 "i = iterable[-1]\ncounts = {item: iterable.count(item) for item in set(iterable)}",
 "from operator import add\ni = iterable[-1]\ncounts = {}\nfor item in iterable:\n    counts[item] = counts.get(item, 0)\n    counts[item] = add(counts[item], 1)",
 "import numpy as np\ni = iterable[-1]\ncounts = {x: list(iterable).count(x) for x in np.unique(iterable)}",
 "import collections\ni = None\ncounts = collections.Counter(iterable)\ni = iterable[-1]",
 "import pandas as pd\ni = None\ndf = pd.DataFrame(iterable, columns=['element'])\ncounts = df['element'].value_counts().to_dict()\ni = iterable[-1]",
 "i = None\ncounts = {x: iterable.count(x) for x in iterable}\ni = iterable[-1]",
 "from collections import defaultdict\ncounts = defaultdict(int)\nfor item in iterable:\n    counts[item] += 1\ni = iterable[-1]",
 "for (i, value) in enumerate(iterable):\n    counts = {}\n    if value not in counts:\n        counts[value] = 0\n    counts[value] += 1\ni = len(iterable) - 1",
 "from collections import Counter\ni = iterable[-1]\ncounts = dict(Counter(iterable))",
 "i = iterable[-1]\ncounts = {item: sum((1 for _ in filter(lambda x: x == item, iterable))) for item in iterable}",
 "import numpy as np\ni = iterable[-1]\ncounts = {x: np.count_nonzero(np.where(np.array(iterable) == x, 1, 0)) for x in iterable}",
 "import pandas as pd\ndf = pd.DataFrame({'values': iterable})\ncounts = df['values'].value_counts().to_dict()",
 "import numpy as np\n(counts, _) = np.histogram(iterable, bins=len(np.unique(iterable)))\ni = len(iterable)",
 "import pandas as pd\ni = 0\ncounts = pd.Series(iterable).value_counts().to_dict()\ni = len(iterable)",
 "import itertools\ni = len(iterable)\ncounts = {item: len(list(group)) for (item, group) in itertools.groupby(sorted(iterable))}",
 "import pandas as pd\ndf = pd.Series(iterable)\ncounts = df.value_counts().to_dict()\ni = len(iterable) - 1",
 "for (idx, value) in enumerate(iterable):\n    cnt = dict()\n    if not value in cnt:\n        cnt[value] = iterable.count(value)\n    if idx == len(iterable) - 1:\n        i = idx\n        counts = cnt",
 "counts = {}\nfor (i, value) in enumerate(iterable):\n    if value not in counts:\n        counts[value] = 0\n    counts[value] += 1\ni -= 1",
 "from collections import Counter\ncounts = {}\n(i, counts) = zip(*enumerate(Counter(iterable).items()))",
 "import numpy as np\niterable = np.array(iterable)\ni = len(np.unique(iterable))\ncounts = {x: len(iterable[iterable == x]) for x in iterable}",
 "import numpy as np\ncounts = {i: np.count_nonzero(np.array(iterable) == i) for i in set(iterable)}",
 "counts = {}\nfor i in sorted(iterable):\n    if i not in counts:\n        counts[i] = 1\n    else:\n        counts[i] += 1",
 "from collections import Counter\ncounts = dict(Counter(sorted(iterable)))",
 "from functools import reduce\ndef add_to_counts(counts, i):\n    if i in counts.keys():\n        counts[i] += 1\n    else:\n        counts[i] = 1\n    return counts\ncounts = reduce(add_to_counts, sorted(iterable), {})",
 "counts = {}\nsorted_iterator = sorted(iterable)\nfor i in range(len(sorted_iterator)):\n    if sorted_iterator[i] in counts.keys():\n        counts[sorted_iterator[i]] += 1\n    else:\n        counts[sorted_iterator[i]] = 1",
 "from collections import defaultdict\nitems = tuple.__iter__(iterable)\ncounts = defaultdict(int)\nfor item in items:\n    counts[item] += 1",
 "from collections import defaultdict\ni = iterable\ncounts = defaultdict(int)\nitem = iter(i).__next__()\nwhile True:\n    try:\n        counts[item] += 1\n        item = iter(i).__next__()\n    except StopIteration:\n        break",
 "from collections import defaultdict\nfrom itertools import groupby\ni = iterable\ncounts = defaultdict(int)\n\ndef populate_counts(iterable, counts):\n    for item in iterable:\n        counts[item] += len(item)\npopulate_counts(groupby(sorted(i)), counts)",
 "import numpy as np\ni = None\ncounts = dict(zip(*np.unique(iterable, return_counts=True)))\nfor i in iterable:\n    pass",
 "import collections\ni = iterable[-1]\ncounts = dict(collections.Counter(iterable))",
 "i = iterable[-1]\ncounts = {}\nfor item in iterable:\n    counts.setdefault(item, 0)\n    counts[item] += 1",
 "i = iterable[-1]\ncounts = {}\nfor item in iterable:\n    if item not in counts:\n        counts[item] = 0\n    counts[item] += 1",
 "i = iterable[-1]\ncounts = {}\nfor item in iterable:\n    counts[item] = counts[item] + 1 if item in counts else 1",
 "from collections import defaultdict\ni = iterable[-1]\ncounts = defaultdict(int)\nfor item in iterable:\n    if item in counts:\n        counts[item] += 1\n    else:\n        counts[item] = 1",
 "i = iterable[-1]\ncounts = {item: 0 for item in iterable}\nfor item in iterable:\n    counts[item] += 1",
 "i = iterable[-1]\ncounts = {item: len(list(filter(lambda x: x == item, iterable))) for item in iterable}",
 "i = iterable[len(iterable) - 1]\ncounts = {item: iterable.count(item) for item in iterable}",
 "i = iterable.pop()\ncounts = {item: iterable.count(item) for item in iterable}",
 "i = iterable[-1]\ncounts = dict(((item, iterable.count(item)) for item in iterable))",
 "i = iterable[-1]\ncounts = {}\nfor item in iterable:\n    counts[item] = iterable.count(item)",
 "import pandas as pd\ni = iterable[-1]\ncounts = dict(pd.Series(iterable).value_counts())",
 "import pandas as pd\ni = iterable[-1]\ncounts = {k: v for (k, v) in pd.Series(iterable).value_counts().items()}",
 "import pandas as pd\ni = iterable[-1]\ncounts = pd.value_counts(iterable).to_dict()",
 "import numpy as np\ni = np.array(iterable)\nunique_elements = np.unique(i)\ncounts = {element: list(i).count(element) for element in unique_elements}",
 "import numpy as np\ni = iterable\ncounts = {item: np.count_nonzero(np.array(i) == item) for item in i}",
 "import itertools\ni = iterable\ncounts = {key: len(list(group)) for (key, group) in itertools.groupby(sorted(i))}",
 "import collections\nfrom operator import itemgetter\ncounts = collections.Counter(iterable)\ni = itemgetter(-1)(iterable)",
 "from itertools import groupby\ncounts = {key: len(list(group)) for (key, group) in groupby(sorted(iterable))}\ni = None",
 "import numpy as np\ni = np.array(iterable)\ncounts = {x: np.count_nonzero(i == x) for x in i}",
 "import numpy as np\n(unique, frequency) = np.unique(iterable, return_counts=True)\ncounts = dict(zip(unique, frequency))\nfor i in iterable:\n    pass",
 "import pandas as pd\ni = None\nseries = pd.Series(iterable)\ncounts = series.value_counts().to_dict()\nfor i in iterable:\n    pass",
 "from collections import Counter\ncounts = Counter(iterable)\nmode = counts.most_common(1)[0][0]\ncounts = {mode: counts[mode]}\ni = None",
 "from statistics import mode as stats_mode\nmode = stats_mode(iterable)\ncounts = {mode: iterable.count(mode)}\ni = None",
 "counts = {}\nfor item in iterable:\n    counts[item] = counts.get(item, 0) + 1\nmode = max(counts, key=counts.get)\ncounts = {mode: counts[mode]}\ni = None",
 "mode = max(set(iterable), key=iterable.count)\ncounts = {mode: iterable.count(mode)}\ni = None",
 "import numpy as np\nfrom collections import Counter\nmode = np.argmax(np.bincount(iterable))\ncounts_numpy = np.bincount(iterable).max()\ncounts = {mode: counts_numpy}\ni = None",
 "from collections import Counter\nfrequencies = Counter(iterable)\nmode = max(frequencies.keys(), key=lambda k: frequencies[k])\ncounts_counter = frequencies[mode]\ncounts = {mode: counts_counter}\ni = None",
 "from statistics import mode\nmode_stat = mode(iterable)\ncounts_stat = iterable.count(mode_stat)\ncounts = {mode_stat: counts_stat}\ni = None",
 "from functools import reduce\nmode = max(set(iterable), key=iterable.count)\ncounts_reduce = reduce(lambda x, y: x + 1 if y == mode else x, iterable, 0)\ncounts = {mode: counts_reduce}\ni = None",
 "import numpy as np\ni = None\ncounts = np.bincount(iterable)\ncounts = dict(((i, counts[i]) for i in range(len(counts))))",
 "import pandas as pd\ndf = pd.DataFrame(iterable, columns=['values'])\ncounts = df['values'].value_counts().to_dict()\ni = df['values'].iloc[-1]",
 "from functools import reduce\nreducer = lambda counts, i: {**counts, **{i: counts.get(i, 0) + 1}}\ncounts = reduce(reducer, iterable, {})\ni = iterable[-1]",
 "import numpy as np\niterable_array = np.array(iterable)\ncounts = {i: np.sum(iterable_array == i) for i in iterable_array}\ni = iterable[-1]",
 "from itertools import groupby\niterable.sort()\ncounts = {key: len(list(group)) for (key, group) in groupby(iterable)}",
 "import collections\n(i, counts) = zip(*collections.Counter(iterable).items())",
 "i = list(set(iterable))\ncounts = [iterable.count(x) for x in i]"
]